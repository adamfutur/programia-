from datetime import datetime, date, timezone
from flask import Blueprint, jsonify, request, abort
from app import db
from app.models import Event


event_blueprint = Blueprint("events", __name__, url_prefix="/events")


def parse_date(date_str):
    try:
        return datetime.strptime(date_str, "%d-%m-%Y").date()
    except (ValueError, TypeError):
        return None


def error_response(message, status_code):
    response = jsonify({"error": message})
    response.status_code = status_code
    return response


@event_blueprint.route("", methods=["POST"])
def create_event():
    if not request.is_json:
        return error_response("Request must be JSON", 400)
    data = request.get_json()

    required_fields = ["name", "date", "venue", "available_tickets", "price"]
    for field in required_fields:
        if field not in data:
            return error_response(f"Missing required field: {field}", 400)

    event_date = parse_date(data["date"])
    if not event_date:
        return error_response("Invalid date format. Use dd-mm-yyyy", 400)

    try:
        available_tickets = int(data["available_tickets"])
        price = float(data["price"])
    except (ValueError, TypeError):
        return error_response("available_tickets must be integer and price must be float", 400)

    event = Event(
        name=data["name"],
        date=event_date,
        venue=data["venue"],
        available_tickets=available_tickets,
        price=price
    )

    try:
        db.session.add(event)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        return error_response("Database error: " + str(e), 500)

    return jsonify(event.to_dict()), 201


@event_blueprint.route("/purchase", methods=["POST"])
def purchase_tickets():
    if not request.is_json:
        return error_response("Request must be JSON", 400)
    data = request.get_json()

    if "event_id" not in data or "quantity" not in data:
        return error_response("Missing required fields: event_id, quantity", 400)

    try:
        event_id = int(data["event_id"])
        quantity = int(data["quantity"])
        if quantity <= 0:
            return error_response("Quantity must be positive integer", 400)
    except (ValueError, TypeError):
        return error_response("event_id and quantity must be integers", 400)

    event = db.session.get(Event, event_id)
    if not event:
        return error_response("Event not found", 404)

    if event.available_tickets < quantity:
        return error_response("Not enough tickets available", 400)

    event.available_tickets -= quantity
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        return error_response("Database error: " + str(e), 500)

    total_amount = quantity * event.price
    return jsonify({
        "message": "Purchase successful",
        "total_amount": total_amount,
        "remaining_tickets": event.available_tickets
    }), 201


@event_blueprint.route("", methods=["GET"])
def get_all_events():
    events = Event.query.order_by(Event.date.asc()).all()
    events_list = [event.to_dict() for event in events]
    return jsonify(events_list), 200


@event_blueprint.route("/<int:event_id>", methods=["GET"])
def get_event(event_id):
    event = db.session.get(Event, event_id)
    if not event:
        return error_response("Event not found", 404)
    return jsonify(event.to_dict()), 200


@event_blueprint.route("/upcoming", methods=["GET"])
def get_upcoming_events():
    start_date_str = request.args.get("startDate")
    end_date_str = request.args.get("endDate")

    utc_now = datetime.now(timezone.utc).date()

    if start_date_str:
        start_date = parse_date(start_date_str)
        if not start_date:
            return error_response("Invalid startDate format. Use dd-mm-yyyy", 400)
    else:
        start_date = utc_now

    if end_date_str:
        end_date = parse_date(end_date_str)
        if not end_date:
            return error_response("Invalid endDate format. Use dd-mm-yyyy", 400)
    else:
        end_date = None

    if end_date and start_date > end_date:
        return error_response("startDate must be less than or equal to endDate", 400)

    query = Event.query.filter(Event.date >= start_date)
    if end_date:
        query = query.filter(Event.date <= end_date)

    events = query.order_by(Event.date.asc()).all()
    events_list = [event.to_dict() for event in events]
    return jsonify(events_list), 200


@event_blueprint.route("/<int:event_id>", methods=["DELETE"])
def delete_event(event_id):
    event = db.session.get(Event, event_id)
    if not event:
        return error_response("Event not found", 404)

    try:
        db.session.delete(event)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        return error_response("Database error: " + str(e), 500)

    return jsonify({"message": "Event deleted"}), 200
