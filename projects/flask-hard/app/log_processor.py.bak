import threading
import queue
import time
from notifications import NotificationManager


class LogProcessor:
    def __init__(self):
        # Queues per log level for prioritization
        self.queues = {
            'CRITICAL': queue.Queue(),
            'WARNING': queue.Queue(),
            'INFO': queue.Queue()
        }

        # Lock for thread-safe log storage
        self.logs_lock = threading.Lock()
        self.logs = []  # Stored logs

        # Metrics and lock
        self.metrics_lock = threading.Lock()
        self.metrics = {
            'logs_processed': 0,
            'notifications_sent': 0
        }

        # Notification manager
        self.notification_manager = NotificationManager()

        # Consumer threads
        self.consumer_threads = []
        self._stop_event = threading.Event()

        # Start consumer threads, one per queue
        self._start_consumer_threads()

    def _start_consumer_threads(self):
        for level, q in self.queues.items():
            t = threading.Thread(target=self._consume_logs, args=(level, q), daemon=True)
            t.start()
            self.consumer_threads.append(t)

    def _consume_logs(self, level, q):
        while not self._stop_event.is_set():
            try:
                log_entry = q.get(timeout=1)
                self.process_log(log_entry)
                q.task_done()
            except queue.Empty:
                continue

    def enqueue_log(self, log_entry):
        # Determine queue based on log level priority
        level = log_entry.get('level', '').upper()
        if level in self.queues:
            self.queues[level].put(log_entry)
        else:
            # If level not in priority queues, put in INFO queue as fallback
            self.queues['INFO'].put(log_entry)

    def process_log(self, log_entry):
        # Store the log
        with self.logs_lock:
            self.logs.append(log_entry)

        # Increment logs_processed metric
        with self.metrics_lock:
            self.metrics['logs_processed'] += 1

        # Send notification if needed
        notified = self.notification_manager.send_notification(log_entry)
        if notified:
            with self.metrics_lock:
                self.metrics['notifications_sent'] += 1

    def get_logs(self, level=None, sort_asc=True):
        with self.logs_lock:
            filtered_logs = self.logs
            if level:
                level = level.upper()
                filtered_logs = [log for log in self.logs if log.get('level', '').upper() == level]

            # Sort by timestamp
            try:
                filtered_logs.sort(key=lambda x: x.get('timestamp'), reverse=not sort_asc)
            except Exception:
                # If timestamp missing or invalid, skip sorting
                pass

            return filtered_logs

    def get_metrics(self):
        with self.metrics_lock:
            # Return a copy to avoid race conditions
            return dict(self.metrics)

    def stop(self):
        self._stop_event.set()
        for t in self.consumer_threads:
            t.join()
